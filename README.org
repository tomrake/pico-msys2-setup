* A raspberrypi/pico-setup fork
:PROPERTIES:
:CUSTOM_ID: a-raspberrypipico-setup-fork
:END:
** Based on a Raspberry Pi-flavored setup
:PROPERTIES:
:CUSTOM_ID: based-on-a-raspberry-pi-flavored-setup
:END:
This bash script has been forked from
https://github.com/raspberrypi/pico-setup along with the associated README.
That README states:

#+begin_quote
Compatibility with any systems not running Raspberry Pi OS or Raspberry
Pi OS Lite is not guaranteed or maintained.

#+end_quote

** The Goal
:PROPERTIES:
:CUSTOM_ID: the-goal
:END:
*** Dedication
Github users: [[https://github.com/lurch][lurch]], [[https://github.com/will-v-pi][will-v-pi]], [[https://github.com/P33M][P33M]], [[https://github.com/liamfraser][liamfraser]], [[https://github.com/fuzzybear3][fuzzybear3]], [[https://github.com/hasenradball][hasenradball]].
And the UK Raspberry Pi team.

*** About updating this project
- This project was created after the 2.2.0 release of the pico-sdk.
- I am uncertain if I will update this for the next release.

*** If you  are a beginner, start with VSCode and the plug-in
- Beginners should use VSCode and the VSCode pico plug-in.
- Be sure you are comfortable with Appendix C of "Getting started with Raspberry Pi Pico-series."
- MSYS2 is NOT the recommended way to develop code by Raspberry Pi.

** Create a Windows MSYS2 development systam  for pico code development.
:PROPERTIES:
:CUSTOM_ID: create-a-msys2-setup-on-windows
:END:
This project is an extension/fork of the [[https://github.com/raspberrypi/pico-setup]] project.
I modified this on a Windows 11 computer using MSYS2 with the UCRT64 Environment.

When executed pico-setup.sh, first the =pico= directory is created in the current directory.
Next the =pico= source repos are downloading in the =pico= directory.
The toolchains are downloaded in the =pico= directory.
The source for the picotool, the debugprobe and openocd are downloaded and compiled in the =pico= directory.
Environment variables are directly set, and added to =~/.bashrc=.


** The cross-compiler toolchains
:PROPERTIES:
:CUSTOM_ID: include-the-cross-compiler-toolchains
:END:
The documentation "Getting Started With Pico" points to an ARM toolchain
on the ARM website. The list of crosscompiler toolchain urls are located in
the source code for the VSCode plug-in. It is the choice of this software
author that the toolchains are to be include the subdirectory of the
pico folder.

** The concept of the full kit
:PROPERTIES:
:CUSTOM_ID: the-concept-of-the-full-kit
:END:
The distribution of code for the pico is a software development kit. The
full kit consists of crosscompiler toolchains, the standard pico
libraries the =sdk=,  =examples=, =extras= and =playground= code.
Certain compiled tools and a specfication of what additional tools are
necessary to build the tools, examples and other code.

*** Windows devices and msys2 packages
:PROPERTIES:
:CUSTOM_ID: windows-devices-and-msys2-packages
:END:
The full kit will require certain software related to the operating
system that hosts the kit. For the msys2 version of the pico kit much of
the pacman packages and the Windows level device hacking of USB and
serial devices are beyond the scope this discussion.

*** The environment interface
:PROPERTIES:
:CUSTOM_ID: the-enviroment-interface
:END:
Enviroment variables are integral to connecting the various =pico=
sources from the =sdk=, =examples=, =extras= and =playground=. Added environment variables index the toolchains and various compiled tools.

**** SDK Source locations
:PROPERTIES:
:CUSTOM_ID: sdk-source-locations
:END:
| Enviroment Variable          | Description                             |
|------------------------------+-----------------------------------------|
| PICO_SDK_PATH                | pico_sdk The core pico libaries         |
| PICO_EXAMPLES_PATH           | pico_examples working example code      |
| PICO_EXTRAS_PATH             | pico_extras beta code                   |
| PICO_PLAYGROUND_PATH         | pico_playground alpha code              |
| PICOTOOL_FETCH_FROM_GIT_PATH | Fixed location of the pictool git clone |

**** Toolchain locations
:PROPERTIES:
:CUSTOM_ID: toolchain-locations
:END:
| Enviroment Variable       | Description                        |
|---------------------------+------------------------------------|
| PICO_TOOLCHAIN_PATH       | The location of the ARM toolchain  |
| PICO_RISCV_TOOLCHAIN_PATH | The location of the RISV toolchain |
| PICO_ARM_TOOLCHAIN_PATH   | The location of a toolchain        |

**** Compiled binaries:
:PROPERTIES:
:CUSTOM_ID: compiled-binaries
:END:
| Enviroment Variable | Description                        |
|---------------------+------------------------------------|
| PICOTOOL_BINARY     | The location of picotool binary    |
| OPENOCD_BINARY      | The location of the openocd binary |
| PIOASM_BINARY       | The location of the pioasm         |
|                     |                                    |

** Notes on toolchains
:PROPERTIES:
:CUSTOM_ID: notes-on-toolchains
:END:
The necessary ARM and RISCV toolchains required to crosscompile source code are defined in the VSCode pico extenstion RaspberryPi.

https://github.com/raspberrypi/pico-vscode/blob/d975f430f3a5daea9e28f2358647ce96fd4eff9b/data/0.18.0/supportedToolchains.ini

* Pico-series microcontroller Command Line Setup
:PROPERTIES:
:CUSTOM_ID: pico-series-microcontroller-command-line-setup
:END:
This script gives you an easy way to setup your Raspberry Pi to be able
to build and run programs on your Pico-series microcontroller from the
command line using MSYS2 tools on Windows.

To download & run this script, you can use the following commands:

#+begin_src sh
wget https://raw.githubusercontent.com/tomrake/pico-msys2-setup/master/pico_setup.sh
./pico_setup.sh
#+end_src



** Compiling and running an example
:PROPERTIES:
:CUSTOM_ID: compiling-and-running-an-example
:END:
After running the setup script, you'll want to run an example to check
everything's working. First go into pico-examples:

#+begin_src sh
cd pico/pico-examples
#+end_src

Depending on the board you're using (eg pico2), replace =build_pico=
with the relevant build directory (eg =build_pico2=) in the following
commands.

#+begin_quote
If you're not using one of the default boards (=pico=, =pico_w=, =pico2=, or
=pico2_w=), you'll need to create a new build directory for your board -
you can do this with this command (replace both instances of =$board=
with the board you are using):

#+begin_example
cmake -S . -B build_$board -GNinja -DPICO_BOARD=$board -DCMAKE_BUILD_TYPE=Debug
#+end_example

#+end_quote

To build the blink example, run the following command:

#+begin_src sh
cmake --build build_pico --target blink
#+end_src

This builds the specified target =blink= in the build folder
=build_pico= - it will probably display =no work to do= because =blink=
was built earlier by =pico_setup.sh=

Then to run it, attach a Pico-series microcontroller in BOOTSEL mode,
and run:

#+begin_src sh
picotool load build_pico/blink/blink.uf2 -vx
#+end_src

This loads the file into Flash on the board, then verifies it was loaded
correctly and reboots the board to execute it

You should now have a blinking LED on your board! For more info on the
=picotool= command which is used to load and query binaries on the
device, see its [[https://github.com/raspberrypi/picotool?tab=readme-ov-file#readme][README]]

** Console Input/Output
:PROPERTIES:
:CUSTOM_ID: console-inputoutput
:END:
*** Debugging UART connections on Windows
:PROPERTIES:
:CUSTOM_ID: debugging-uart-connections-on-windows
:END:
**** A works on my computer warning.
:PROPERTIES:
:CUSTOM_ID: a-works-on-my-computer-warning.
:END:
For me this was a half-a-day-hacking-session, I may have notes to add
details but you hardware may vary. The RaspberryPi debug probe is a
cmsis-dap protocol which converts the uart and SWD port data into serial
data over USB. I need to add and configure various drivers to get serial
communications to work between my computer, the debugprobe and my
pico2_w board.

*** Modify this section to document the msys2 package tio
:PROPERTIES:
:CUSTOM_ID: modify-this-section-to-document-the-msys2-package-tio
:END:
To view console output, you can either connect the UART output to a
[[https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html#getting-started][Debug Probe]] (or similar) and use =stdio_uart= (see the [[https://github.com/raspberrypi/pico-examples/blob/master/hello_world/serial][hello_serial example]]),
or you can use =stdio_usb= (see the [[https://github.com/raspberrypi/pico-examples/blob/master/hello_world/usb][hello_usb example]]).

First, build & run the example for your =stdio= choice on your
Pico-series microcontroller with the same commands as before:

#+begin_src sh
cmake --build build_pico --target hello_serial
picotool load build_pico/hello_world/serial/hello_serial.uf2 -vx
#+end_src

I used a debugprobe and the msys2 package tio to connect to
the serial devices.

Then attach =tio= to view the output:

The command:

#+begin_src sh
tio -l
#+end_src

Will list the available serial devices.

Then attach =tio= to view the output of hello_serial

#+begin_src sh
tio -b 115200 /dev/ttyS3
#+end_src

Then attach =tio= to view the output of hello_usb

#+begin_src sh
tio -b 115200 /dev/ttyS2
#+end_src

The port number may be different, so also try =/dev/ttyACM1= etc - and
on other OSes may be entirely different (eg =/dev/tty.usbmodem0001= on
MacOS)

To exit tio, type Ctrl+T then Q

** Debugging with OpenOCD and GDB
:PROPERTIES:
:CUSTOM_ID: debugging-with-openocd-and-gdb
:END:
To debug programs on the Pico-series microcontroller, you first need to
attach a debugger such as the [[https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html#getting-started][Debug Probe]]. Once that's done, you can attach OpenOCD to your Pico-series
microcontroller with this command (replace =rp2040.cfg= with
=rp2350.cfg=, if using an RP2350-based board like a Pico 2):

#+begin_src sh
openocd -f interface/cmsis-dap.cfg -f target/rp2040.cfg -c "adapter speed 5000"
#+end_src

In a separate window, you can run GDB and connect to that OpenOCD
server:

#+begin_src sh
gdb-multiarch -ex "target extended-remote localhost:3333"
#+end_src

Then in GDB, run the following:

#+begin_example
file build_pico/blink/blink.elf
monitor reset init
load
continue
#+end_example

To exit GDB, use Ctrl+D twice. This will leave your Pico-series
microcontroller in the halted state, so you will need to unplug and
replug it to get it running again. To leave the device running, you can
use:

#+begin_example
monitor reset run
#+end_example

before exiting to leave the Pico running the code.

*** Useful GDB Commands
:PROPERTIES:
:CUSTOM_ID: useful-gdb-commands
:END:
To configure the GDB layout, the following commands can be useful:
- =layout src= - displays the source code
- =layout split= - displays the source code and the assembly instructions
- =layout regs= - displays the current register contents

To step through code, you can use:
- =step= or =s= - step to the next line of code, and into any functions
- =next= or =n= - step to the next line of code, without stepping into functions
- =finish= or =fin= - step out of the current function

To step through assembly instructions, you can use:
- =stepi= or =si= - step to the next assembly instruction, and into any functions
- =nexti= or =ni= - step to the next assembly instruction, without stepping into functions

While stepping, you can just press enter again to repeat the previous
command

To set breakpoints, use the =break= or =b= command plus the location of the breakpoint. The location can be:
- A function name - =break main=
- A line of code - =break 12=
- Either of those in a specific file - =break blink.c:48=, =break blink.c:main=
- A specific memory address - =break *0x10000ff2=

For more details on debugging with GDB, see the [[https://sourceware.org/gdb/current/onlinedocs/gdb.html/][GDB docs]]

** Multiple Terminals
:PROPERTIES:
:CUSTOM_ID: multiple-terminals
:END:
When debugging or viewing serial output, you might want multiple
programs open in different terminals, as they all need to run at the
same time. Under MSYS2 you can run separate MSYS2 instances.
You can use tmux and create a session with the various tmux windows running multiple programs.


!!!! FIX THIS EXAMPLE !!!!

Alternatively, you can use something like  =tmux= to allow you
to open new terminals and detach from them - for example using =tmux=:
- =screen -S minicom= - open a new terminal called =minicom=
- Ctrl+A then D - detach from the current terminal
- =screen -r minicom= - re-attach to an existing terminal called =minicom=
- =screen -ls= - list existing terminals

For more details on =screen=, see the
[[https://www.gnu.org/software/screen/manual/screen.html][screen docs]]

** Setup SDK & Picotool
:PROPERTIES:
:CUSTOM_ID: setup-sdk-picotool
:END:
**** Picotool
:PROPERTIES:
:CUSTOM_ID: picotool
:END:
Run this from the path you want to store picotool:

#+begin_src sh
git clone https://github.com/raspberrypi/picotool.git
#+end_src

Then install libusb
- On MSYS2, ensure that libusb is installed.
#+begin_src emacs-lisp
pacboy -S libusb:u
#+end_src

Then build and install picotool using these commands:

#+begin_src sh
cd picotool
cmake -S . -B build
cmake --build build
sudo cmake --install .
#+end_src

For more details on building & installing picotool, see its [[https://github.com/raspberrypi/picotool?tab=readme-ov-file#readme][README]]

*** Test it's working with pico-examples
:PROPERTIES:
:CUSTOM_ID: test-its-working-with-pico-examples
:END:
Change to pico-examples:

#+begin_src sh
cd pico/pico-examples
#+end_src

Build them all, replacing all occurences of =$board= with the pico board
you are using:

#+begin_src sh
cmake -S . -B build_$board -GNinja -DPICO_BOARD=$board -DCMAKE_BUILD_TYPE=Debug
cmake --build build_$board
#+end_src

#+begin_quote
The cmake =-S= flag indicates the source directory, and the =-B= flag
tells cmake the name of the output-directory to create, which is then
supplied to the =--build= flag

#+end_quote

Put your board in BOOTSEL mode and use =picotool= to load the blink
example:

#+begin_src sh
picotool load build_$board/blink/blink.uf2 -vx
#+end_src

You should now have a blinking LED on your board.
